title: In with the new
code-theme: blackboard

h1. Who am I?

<center>
!images/code_monkey.jpg!
</center>

h1. Where do I hail from?

<center>
!images/road_warrior.jpg!
</center>

h1. What do we do?

<center>
!images/question.jpg!
</center>

h1. What kind of stuff do I work with?

<center>
!images/python.gif!
!images/ruby.gif!
!images/php.gif!
!images/vmware.gif!
!images/rails.png!
!images/django.gif!
!images/jquery.gif!
!images/node.png!
!images/mongodb.png!
!images/redis.gif!
</center>

h1. What is this talk about?

!images/what.png!

h1. What is this talk about?

h2. continued

<p>&nbsp;</p>

<ul>
<li>Distributed Version Control</li>
<li>NoSQL</li>
<li>Web Frameworks</li>
<li>Event Driven Servers</li>
<li>Message Queue Servers</li>
</ul>

h1. Not "out with the old"

<center>
!images/hulk.jpg!
</center>

h1. Do I actually use any of this stuff?

<center>
!images/wrench.jpg!
</center>

h1. Distributed Version Control

<center>
!images/distributed.gif!
</center>

h1. Centralized Model

<center>
!images/traditional_vc.png!
</center>

h1. Centralized SCM systems

  * CVS
  * Subversion
  * ClearCase
  * Perforce
  * Visual Studio Team System

h1. One master copy

<center>
!images/master.jpg!
</center>

h1. All collaborators work on the same repository

<center>
!images/collaborators.jpg!
</center>

h1. Network is required for most operations

<center>
!images/internet.jpg!
</center>

h1. Distributed Model

<center>
!images/distributed_vc.png!
</center>

h1. Distributed SCM systems

  * Git
  * Mercurial
  * Arch
  * Bazaar
  * Darcs
  * Bitkeeper

h1. Multiple "masters"

<center>
!images/masters.jpg!
</center>

h1. Everyone works on their own copy of the repository

<p>&nbsp;</p>

<center>
!images/everymanforhimself.jpg!
</center>

h1. No network needed

<center>
!images/nonetwork.jpg!
</center>

h1. It's not too late, convert today!

<center>
!images/conversion.jpg!
</center>

h1. No platform left behind

<center>
!images/linux.jpg!
!images/osx.jpg!

!images/windows.jpg!
!images/bsd.jpg!
</center>

h1. Command line utils

<center>
!images/commandline.png!
</center>

h1. GUI utils

<center>
!images/tortoise.jpg!
</center>

h1. Cryptographic history

<center>
!images/crypto.png!
</center>

h1. Simplified branching

<p>&nbsp;</p>

<center>
!images/branching.png!
</center>

h1. Why you should consider DVCS

<center>
!images/consider.jpg!
</center>

h1. Redundancy

<center>
!images/redundant.jpg!
</center>

h1. No network needed

<p>&nbsp;</p>

<center>
!images/failwhale.gif!
</center>

h1. Encourages commits

<center>
!images/hardwork.jpg!
</center>

h1. Private work environment

<center>
!images/privacy.jpg!
</center>

h1. Still can have an "official" repo

<center>
!images/enforce.jpg!
</center>

h1. Great for large projects

<center>
!images/large.jpg!
</center>

h1. Why you should NOT consider DVCS

<center>
!images/rejected.jpg!
</center>

h1. Centralized systems are getting some of the same features

<center>
!images/steal.jpg!
</center>

h1. Easier to enforce an "official" repo

<center>
!images/official.jpg!
</center>

h1. Can't or won't allow personal copies of repos

<center>
!images/noprivate.jpg!
</center>

!SLIDE

<p>&nbsp;</p>

<center>
!images/nosql.png!
</center>

h1. What is NoSQL?

<center>
!images/what.png!
</center>

h1. Buzzword

<center>
!images/bee.jpg!
</center>

h1. Flexible table schema

<center>
!images/database.jpg!
</center>

h1. Key-value

<center>
!images/key.jpg!
</center>

h1. Key-value

h2. Software

 * MemcacheDB
 * Tokyo Cabinet
 * Redis
 * Amazon SimpleDB

h1. Document oriented

<center>
!images/documents.jpg!
</center>

h1. Document oriented

h2. Software

 * MongoDB
 * CouchDB
 * RavenDB

h1. Column oriented

<center>
!images/column.jpg!
</center>

h1. Column oriented

h2. Software

 * LucidDB
 * MonetDB
 * Google BigTable (sort of)

h1. Avoid the join

<center>
!images/join.jpg!
</center>

h1. Polymorphism baby!

<center>
!images/morph.jpg!
</center>

h1. Horizontal scalability

<center>
!images/horizontal.jpg!
</center>

h1. Weak/eventual consistency

<center>
!images/consistent.jpg!
</center>

h1. Why you should consider NoSQL?

<center>
!images/consider.jpg!
</center>

h1. Performance

<center>
!images/performance.jpg!
</center>

h1. Scalability

<center>
!images/scalable.jpg!
</center>

h1. (auto)Sharding

<center>
!images/sharding.jpg!
</center>

h1. Simplified replication

<center>
!images/replicant.jpg!
</center>

h1. Versatile

<center>
!images/versatile.jpg!
</center>

h1. Why you should NOT consider NoSQL

<center>
!images/rejected.jpg!
</center>

h1. Doesn't fit

<center>
!images/fit.jpg!
</center>

h1. Need complex joins/business logic

<center>
!images/joins.jpg!
</center>

h1. Need ODBC

<center>
!images/odbc.jpg!
</center>

h1. Weak/eventual consistency

<center>
!images/consistency.jpg!
</center>

h1. Web frameworks

<center>
!images/wordle.png!
</center>

h1. What is MVC

<center>
!images/mvc.png!
</center>

h1. Design philosophy

<center>
!images/design.jpg!
</center>

h1. DRY

 * Don't
 * Repeat
 * Yourself

h1. ORM

 * Object

 * Relational

 * Mapping

h1. ORM

h2. Abstraction over data

<center>
!images/orm.jpg!
</center>

h1. ORM

h2. No SQL statements(mostly)

Instead of your code looking like this

<% code do %>res = mysql.query("SELECT * FROM PEOPLE")
res.each do |row|
  puts row['first_name'] + " " + row['last_name']
end
<% end %>

It will look something like this

<% code do %>people = Person.find(:all)

people.each do |person|
  puts person.first_name + " " + person.last_name
end
<% end %>

h1. ORM

h2. Inserts

Instead of your code looking like this

<% code do %>mysql.query("INSERT INTO people(first_name, last_name)
  VALUES ('Schmoe', 'Joe')");
<% end %>

It will look something like this

<% code do %>Person.create({:first_name => 'Joe', :last_name => 'Schmoe'})
<% end %>

h1. Templating

<center>
!images/erb.png!
</center>

h1. Model

<center>
!images/data.jpg!
</center>

h1. Model

h2. Data

<center>
!images/matrix.jpg!
</center>

h1. Model

h2. Business logic

<% code do %>
class Album < ActiveRecord::Base
    has_many :tracks
end

class Track < ActiveRecord::Base
    belongs_to :album
end

album = Album.create(:title => 'Black and Blue',
    :performer => 'The Rolling Stones')
album.tracks.create(:track_number => 1, :title => 'Hot Stuff')

album = Album.create(:title => 'Sticky Fingers',
    :performer => 'The Rolling Stones')
album.tracks.create(:track_number => 1, :title => 'Brown Sugar')

puts Album.find_by_title('Sticky Fingers').title  # Sticky Fingers
puts Track.find_by_title('Hot Stuff').album_id    # 1
<% end %>

h1. View

<center>
!images/surfin.jpg!
</center>

h1. View

h2. Presentation

<center>
!images/optimus.jpg!
</center>

h1. View

h2. “The Web”

h1. Controller

h1. Controller

h2. The tie that binds

h1. Controller

h2. Flow control

h1. JavaScript

h1. JavaScript

h2. DOM

h1. JavaScript

h2. Accessibility/Unobtrusive scripting

h1. JavaScript

h2. Compatibility

h1. JavaScript

h2. Cross browser

h1. JavaScript

h2. New web features

h1. Technologies

h1. MVC

 * Rails
 * Sinatra
 * Django
 * CakePHP
 * CodeIgniter
 * Limonade

h1. Javascript

 * jQuery
 * Prototype
 * Mootools
 * Modernizr

